/*
  Jetson ↔ Arduino Serial Protocol v0.1
  Request : SEQ,CMD,TARGET,ARG1[,ARG2...]\n
  Response: SEQ,OK[,INFO]\n
            SEQ,ERR,ERRCODE[,INFO]\n
*/

#include <Arduino.h>

static const uint32_t BAUD = 115200;
static const uint16_t LINE_MAX = 96;

// Watchdog: 마지막 유효 제어 명령(SV/DC/STOP) 이후 이 시간(ms) 동안 아무 제어가 없으면 DC 모터 정지
static const uint32_t CONTROL_WATCHDOG_MS = 500;
static uint32_t last_control_ms = 0;

enum class CmdType { SV, DC, STOP, PING, GET, UNKNOWN };

static bool is_target_servo(const String &t) {
  return (t == "EAR_L" || t == "EAR_R" || t == "NECK_PITCH");
}
static bool is_target_dc(const String &t) {
  return (t == "WHEEL_L" || t == "WHEEL_R");
}

// 하드웨어 연결 전: 더미 적용 함수 (나중에 여기만 실제 제어로 교체)
static void apply_servo(const String &target, int angle_deg) {
  // TODO: Servo library + write(angle_deg)
  // 지금은 디버그 출력만
  (void)target;
  (void)angle_deg;
}

static void apply_dc(const String &target, int speed) {
  // TODO: TB6612FNG 제어(PWM/AIN/BIN/STBY)
  // 지금은 디버그 출력만
  (void)target;
  (void)speed;
}

static void stop_all() {
  apply_dc("WHEEL_L", 0);
  apply_dc("WHEEL_R", 0);
}

// 응답 헬퍼
static void resp_ok(uint16_t seq, const String &info = "") {
  if (info.length() > 0) {
    Serial.print(seq); Serial.print(",OK,"); Serial.println(info);
  } else {
    Serial.print(seq); Serial.println(",OK");
  }
}
static void resp_err(uint16_t seq, const String &code, const String &info = "") {
  Serial.print(seq); Serial.print(",ERR,"); Serial.print(code);
  if (info.length() > 0) {
    Serial.print(","); Serial.print(info);
  }
  Serial.println();
}

static CmdType parse_cmd(const String &cmd) {
  if (cmd == "SV") return CmdType::SV;
  if (cmd == "DC") return CmdType::DC;
  if (cmd == "STOP") return CmdType::STOP;
  if (cmd == "PING") return CmdType::PING;
  if (cmd == "GET") return CmdType::GET;
  return CmdType::UNKNOWN;
}

static bool parse_u16(const String &s, uint16_t &out) {
  if (s.length() == 0) return false;
  for (size_t i = 0; i < s.length(); i++) {
    if (!isDigit(s[i])) return false;
  }
  long v = s.toInt();
  if (v < 0 || v > 65535) return false;
  out = (uint16_t)v;
  return true;
}

static bool parse_i32(const String &s, int &out) {
  if (s.length() == 0) return false;
  // String::toInt는 앞 공백/부호 처리 가능. 여기선 형식 엄격하게 체크
  int start = 0;
  if (s[0] == '-') start = 1;
  if (start == (int)s.length()) return false;
  for (int i = start; i < (int)s.length(); i++) {
    if (!isDigit(s[i])) return false;
  }
  out = s.toInt();
  return true;
}

static void handle_line(String line) {
  line.trim();                // CRLF 대비
  if (line.length() == 0) return;
  if (line.length() > LINE_MAX) {
    // SEQ를 모르므로 0으로 응답
    resp_err(0, "FMT", "LINE_TOO_LONG");
    return;
  }

  // CSV split
  // 최소: SEQ,CMD,TARGET
  String fields[6];
  int count = 0;
  int start = 0;

  while (true) {
    int comma = line.indexOf(',', start);
    if (comma == -1) {
      if (count < 6) fields[count++] = line.substring(start);
      break;
    }
    if (count < 6) fields[count++] = line.substring(start, comma);
    start = comma + 1;
    if (count >= 6) break;
  }

  if (count < 3) {
    resp_err(0, "FMT", "FIELD_COUNT");
    return;
  }

  uint16_t seq = 0;
  if (!parse_u16(fields[0], seq)) {
    resp_err(0, "FMT", "BAD_SEQ");
    return;
  }

  CmdType cmd = parse_cmd(fields[1]);
  String target = fields[2];

  switch (cmd) {
    case CmdType::PING: {
      // "SEQ,PING,NA"
      resp_ok(seq, "PONG");
      return;
    }

    case CmdType::GET: {
      // "SEQ,GET,VER" / "SEQ,GET,STATE"
      if (target == "VER") {
        resp_ok(seq, "VER,0.1");
      } else if (target == "STATE") {
        // 예시 상태. 필요하면 확장
        resp_ok(seq, "STATE,ARMED");
      } else {
        resp_err(seq, "ID", "UNKNOWN_GET_TARGET");
      }
      return;
    }

    case CmdType::STOP: {
      // "SEQ,STOP,ALL"
      if (target != "ALL") {
        resp_err(seq, "ID", "STOP_TARGET_NOT_ALL");
        return;
      }
      stop_all();
      last_control_ms = millis();
      resp_ok(seq);
      return;
    }

    case CmdType::SV: {
      // "SEQ,SV,<SERVO_ID>,<ANGLE>"
      if (count < 4) {
        resp_err(seq, "FMT", "FIELD_COUNT");
        return;
      }
      if (!is_target_servo(target)) {
        resp_err(seq, "ID", "UNKNOWN_TARGET");
        return;
      }
      int angle = 0;
      if (!parse_i32(fields[3], angle)) {
        resp_err(seq, "FMT", "BAD_ANGLE");
        return;
      }
      // 임시 범위(조립 후 캘리브레이션으로 좁힐 예정)
      if (angle < 0 || angle > 180) {
        resp_err(seq, "RANGE", "ANGLE_OUT");
        return;
      }
      apply_servo(target, angle);
      last_control_ms = millis();
      resp_ok(seq);
      return;
    }

    case CmdType::DC: {
      // "SEQ,DC,<MOTOR_ID>,<SPEED>"
      if (count < 4) {
        resp_err(seq, "FMT", "FIELD_COUNT");
        return;
      }
      if (!is_target_dc(target)) {
        resp_err(seq, "ID", "UNKNOWN_TARGET");
        return;
      }
      int speed = 0;
      if (!parse_i32(fields[3], speed)) {
        resp_err(seq, "FMT", "BAD_SPEED");
        return;
      }
      if (speed < -255 || speed > 255) {
        resp_err(seq, "RANGE", "SPEED_OUT");
        return;
      }
      apply_dc(target, speed);
      last_control_ms = millis();
      resp_ok(seq);
      return;
    }

    default:
      resp_err(seq, "NA", "UNKNOWN_CMD");
      return;
  }
}

void setup() {
  Serial.begin(BAUD);
  while (!Serial) { /* 일부 보드에서 필요 */ }

  last_control_ms = millis();
  resp_ok(0, "BOOT,VER,0.1");
}

void loop() {
  // 라인 수신
  static String buf;
  while (Serial.available() > 0) {
    char c = (char)Serial.read();
    if (c == '\n') {
      String line = buf;
      buf = "";
      handle_line(line);
    } else {
      // 너무 길어지면 버퍼 리셋(형식 오류로 처리)
      if (buf.length() < LINE_MAX + 8) buf += c;
    }
  }

  // Watchdog: 일정 시간 제어 명령이 없으면 DC 정지
  uint32_t now = millis();
  if (now - last_control_ms > CONTROL_WATCHDOG_MS) {
    stop_all();
    // 계속 stop을 반복 호출하지 않도록 last_control 갱신
    last_control_ms = now;
    // 필요하면 로그: Serial.println("0,OK,WATCHDOG_STOP");
  }
}
